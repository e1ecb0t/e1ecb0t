import os

from line_profiler import profile

from utils.Generator import *
from utils.paser import *

current_path = os.path.dirname(os.path.abspath(__file__))


"""
该程序主要实现了随机生成算术表达式和计算表达式的功能,其主要算法流程如下:

随机生成算术表达式
(1) 在Arithmetic类中,随机生成运算符个数、操作数个数,并设置值域范围。

(2) 随机生成操作数列表和运算符列表。

(3) 构建表达式的中缀表达式,中间可能随机插入括号。

(4) 删除无用括号,返回表达式列表。

计算表达式
(1) 在Calculate类中,将中缀表达式转化为后缀表达式。

(2) 使用栈的方式计算后缀表达式:遍历后缀表达式,数字入栈,操作符时取栈顶两个元素进行运算,结果入栈,直到遍历完表达式。

(3) 返回最终计算结果。

生成多条随机表达式
(1) 在Generator类中,通过多进程实现表达式生成和IO写入并发。

(2) 一个进程随机生成表达式并放入队列。

(3) 另一个进程从队列中取出表达式,写入文件。

(4) 使用缓冲区方式批量写文件,避免IO频繁。

主要涉及数据结构有列表、栈、队列等,算法包括中缀转后缀、栈计算后缀表达式等。
使用多进程并发提高效率,缓冲区优化IO操作。


还可以优化的地方：
表达式随机生成算法可以优化:
(1) 可以使用更加合理的方法生成操作数,而不是简单的随机数,可以makeData更具有代表性。

(2) 可以通过控制运算符的频次,让生成的表达式更加合理,不会出现运算符过多或者过少的情况。

(3) 可以建立运算符优先级,让生成的表达式符合运算规律。

(4) 可以改进括号插入算法,避免无效括号的出现。

表达式计算算法可以优化:
(1) 中缀表达式转后缀表达式时,可以不用每次都将运算符栈清空,从而提高效率。

(2) 计算时可以直接使用 Fraction 类进行运算,而不是中转字符串,可以简化运算过程。

并发控制可以改进:
(1) 可以使用线程池,控制生产者和消费者线程数量。

(2) 可以使用更加高效的数据结构,如队列替代栈。

(3) 可以根据具体需求选择 IO 写入方式,适当调整缓冲区大小。

其他:
(1) 增加表达式去重逻辑,避免重复。

(2) 模块化设计,提高代码复用性和可维护性。

(3) 增加完善的日志和异常处理。

(4) 使用测试驱动开发,增加单元测试,提高健壮性。

这些都是可以考虑的优化方向,需要根据具体的应用场景进行平衡和设计。但总体来说,优化生成算法、计算算法和并发控制可能带来较大的性能提升。
"""





@profile
def mainfuction():

    add_path = ''
    # 识别并获取命令行参数
    arg = arg_parse()

    print("+----------------------------------------------------------+\n"
          "|                 欢迎使用四则运算算式生成器                    |\n"
          "+----------------------------------------------------------+\n"
          "|                1. -n:  输入并获取生成的题目数量               |\n"
          "|                2. -r:  输入并获取参与运算的最大值              |\n"
          "|                3. -e:  选择题目文件                         |\n"
          "|                4. -a:  选择答案文件                         |\n"
          "+----------------------------------------------------------+\n"
          )



    # 否则使用命令行操作
    try:
        # 生成题目及答案或者检查答案，两者不能同时进行
        if (arg.e or arg.a) and (arg.n or arg.r):
            raise IOError
        elif arg.a and arg.e:
            # 输入参数正确，执行检查代码部分
            inspect(os.path.join(current_path, arg.a[0]), os.path.join(current_path, arg.e[0]))
        elif arg.n and arg.r:
            # 输入参数正确，执行生成题目和答案文件Grade?.txt
            Generator(arg.n[0], arg.r[0]).multi_processor()
        else:
            print("帮助信息: 参数输入错误")
    except Exception as e:
        print(e)

if __name__ == '__main__':
    mainfuction()